//#include <TApplication.h>
#include <TCanvas.h>
#include <TH3D.h>
#include <iostream>
#include <TString.h>

void drawMirror(int time_pos=0, int doSave=0, int move=1)
{
  const double tMax=150.;
  TH3D *h3mirror= new TH3D("h3mirror","h3mirror;x;y;t",
			   150,-10.,140.,400,-15.,15.,
			   75,-10.,tMax);
  h3mirror->SetStats(0);

  for (int ibx=0; ibx<h3mirror->GetNbinsX(); ibx++) {
    for (int iby=0; iby<h3mirror->GetNbinsY(); iby++) {
      for (int ibt=0; ibt<h3mirror->GetNbinsZ(); ibt++) {
	h3mirror->SetBinContent(ibx,iby,ibt,0);
	h3mirror->SetBinError(ibx,iby,ibt,0);
      }
    }
  }

  int nTimePoints=30;
  double tMin=0;
  double tH=(80-tMin)/(nTimePoints-1);
  

  int nMirrXPoints=8;
  double yMirrPos1=-4.0, yMirrPos2=4.0;
  double tPos= tMin + time_pos*tH;
  double xVelPerTime=4*move;
  int nBeamTicks=8;
  double xMirrMin=xVelPerTime*(tPos-2), xMirrMax=xVelPerTime*(tPos+2);
  double xMirrH=(nMirrXPoints==1) ? 0 : (xMirrMax-xMirrMin)/(nMirrXPoints-1);

  double beamYLen= (yMirrPos2-yMirrPos1)/4;
  double nBeamFullSize=80;
  TH3D* h3beam= (TH3D*)h3mirror->Clone("h3beam");
  h3beam->SetTitle("h3beam");
  h3beam->Reset();
  int beamTick=time_pos%nBeamTicks;
  double beamHeadWeight=8;
  
  if (beamTick==0 || beamTick==1) {
    double beamX= (xMirrMin+xMirrMax)/2;
    double beamYMin= yMirrPos1;
    int nBeamSize= nBeamFullSize;
    double beamYMax= nBeamSize/double(nBeamFullSize)*beamYLen+yMirrPos1;
    double beamH= (beamYMax-beamYMin)/(nBeamSize-1);
    for (int ib=0; ib<nBeamSize; ib++) {
      h3beam->Fill(beamX, beamYMin+ib*beamH, tPos, 0.15);
    }
    h3beam->Fill(beamX, beamYMax, tPos, beamHeadWeight);
  }
  else if ((beamTick==2) || (beamTick==3)) {
    double beamX= (xMirrMin+xMirrMax)/2;
    double beamCenter= (yMirrPos1+yMirrPos2)/2;
    double beamYMin= beamCenter;
    double beamYMax= beamCenter + beamYLen * ((beamTick==2)? 1.5 : -1.5);
    int nBeamSize= nBeamFullSize;
    double beamH= (beamYMax-beamYMin)/(nBeamSize-1);
    for (int ib=0; ib<nBeamSize; ib++) {
      h3beam->Fill(beamX, beamYMin+ib*beamH, tPos, 0.15);
    }
    h3beam->Fill(beamX, beamYMax, tPos, beamHeadWeight);
  }
  else if (beamTick==4 || beamTick==5) {
    double beamX= (xMirrMin+xMirrMax)/2;
    double beamYMin= yMirrPos2;
    double beamYMax= yMirrPos2 - beamYLen;
    int nBeamSize= nBeamFullSize;
    double beamH= (beamYMax-beamYMin)/(nBeamSize-1);
    for (int ib=0; ib<nBeamSize; ib++) {
      h3beam->Fill(beamX, beamYMin+ib*beamH, tPos, 0.15);
    }
    h3beam->Fill(beamX, beamYMax, tPos, beamHeadWeight);
  }
  else {
    double beamX= (xMirrMin+xMirrMax)/2;
    double beamCenter= (yMirrPos1+yMirrPos2)/2;
    double beamYMin= beamCenter;
    double beamYMax= beamCenter - beamYLen * 0.7;
    int nBeamSize= nBeamFullSize/2;
    double beamH= (beamYMax-beamYMin)/(nBeamSize-1);
    for (int ib=0; ib<nBeamSize; ib++) {
      h3beam->Fill(beamX, beamYMin+ib*beamH, tPos, 0.15);
    }
    h3beam->Fill(beamX, beamYMax, tPos, beamHeadWeight);
  }

  for (int i=0; i<nMirrXPoints; i++) {
    double x= xMirrMin + xMirrH * i;
    h3mirror->Fill(x,yMirrPos1, tPos,12);
    h3mirror->Fill(x,yMirrPos2, tPos,12);
  }

  TCanvas *cx= new TCanvas("cx","cx",1000,800);
  h3mirror->SetTitle("");
  h3mirror->SetMarkerColor(kBlue);
  h3mirror->Draw("LEGO");
  h3beam->SetMarkerColor(kRed);
  h3beam->SetLineColor(kRed);
  h3beam->Draw("LEGOsame");
  cx->Update();

  if (doSave) {
    TString form= (time_pos<10) ? "frame_0%d.png" : "frame_%d.png";
    if (xVelPerTime==0) form.Prepend("fixed_");
    form.Prepend(Form("ntp%d_",nTimePoints));
    TString fname=Form(form,time_pos);
    cx->SaveAs(fname);
  }
}
